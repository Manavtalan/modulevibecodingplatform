import type { SandpackFiles } from "@codesandbox/sandpack-react";

export interface GenFile {
  path: string;
  content: string;
}

export type SandpackTemplate = "react-ts";

export interface PreviewAdapterResult {
  template: SandpackTemplate;
  files: SandpackFiles;
  dependencies: Record<string, string>;
}

/**
 * Fixed dependencies for Sandpack - never generated by AI
 */
export const FIXED_SANDPACK_DEPS = {
  react: "18.2.0",
  "react-dom": "18.2.0",
  tailwindcss: "3.4.1",
  autoprefixer: "10.4.16",
  postcss: "8.4.31",
};

/**
 * Base template files that are always included
 * These are read from template/base-vite-react-tailwind/
 */
const BASE_TEMPLATE_FILES: Record<string, string> = {
  "/index.html": `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Module Preview</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <body class="bg-slate-950">
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>`,
  
  "/package.json": JSON.stringify({
    name: "module-preview-template",
    version: "1.0.0",
    private: true,
    scripts: {
      dev: "vite",
      build: "vite build",
      preview: "vite preview"
    },
    dependencies: {
      react: "18.2.0",
      "react-dom": "18.2.0"
    },
    devDependencies: {
      "@types/react": "^18.2.0",
      "@types/react-dom": "^18.2.0",
      autoprefixer: "^10.4.16",
      postcss: "^8.4.31",
      tailwindcss: "^3.4.1",
      typescript: "^5.3.3",
      vite: "^5.0.0"
    }
  }, null, 2),

  "/tsconfig.json": JSON.stringify({
    compilerOptions: {
      target: "ESNext",
      useDefineForClassFields: true,
      lib: ["DOM", "DOM.Iterable", "ESNext"],
      allowJs: false,
      skipLibCheck: true,
      esModuleInterop: true,
      allowSyntheticDefaultImports: true,
      strict: true,
      forceConsistentCasingInFileNames: true,
      module: "ESNext",
      moduleResolution: "bundler",
      resolveJsonModule: true,
      isolatedModules: true,
      noEmit: true,
      jsx: "react-jsx"
    },
    include: ["src"]
  }, null, 2),

  "/vite.config.ts": `import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
});`,

  "/postcss.config.cjs": `module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};`,

  "/tailwind.config.cjs": `/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
};`,

  "/src/main.tsx": `import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);`,

  "/src/index.css": `@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  @apply bg-slate-950 text-slate-50 antialiased;
}`,
};

/**
 * Normalize file path to ensure it starts with /
 */
function normalizePath(path: string): string {
  return path.startsWith('/') ? path : `/${path}`;
}

/**
 * Build Sandpack files by merging base template with AI-generated files
 * AI files can only override src/App.tsx and src/components/*
 */
export function buildSandpackFiles(aiFiles: Record<string, string>): SandpackFiles {
  const sandpackFiles: SandpackFiles = {};

  // 1. Add all base template files first
  for (const [path, content] of Object.entries(BASE_TEMPLATE_FILES)) {
    sandpackFiles[path] = { code: content };
  }

  // 2. Override with AI-generated files (only src/App.tsx and src/components/*)
  for (const [path, content] of Object.entries(aiFiles)) {
    const normalizedPath = normalizePath(path);
    
    // Only allow AI to override src/App.tsx and src/components/*
    if (normalizedPath === '/src/App.tsx' || normalizedPath.startsWith('/src/components/')) {
      sandpackFiles[normalizedPath] = { code: content };
    } else {
      console.warn(`[preview] Ignoring AI file outside allowed paths: ${normalizedPath}`);
    }
  }

  return sandpackFiles;
}

/**
 * Convert Module's API response to Sandpack format
 * Expects files in format: { "src/App.tsx": "...", "src/components/Hero.tsx": "..." }
 */
export function adaptFilesToSandpack(files: GenFile[]): PreviewAdapterResult {
  // Convert GenFile[] to Record<string, string>
  const aiFilesMap: Record<string, string> = {};
  for (const file of files) {
    aiFilesMap[file.path] = file.content;
  }

  // Validate: Must have src/App.tsx
  if (!aiFilesMap['src/App.tsx'] && !aiFilesMap['/src/App.tsx']) {
    throw new Error('Generated code missing src/App.tsx');
  }

  // Build final file map with base template + AI files
  const sandpackFiles = buildSandpackFiles(aiFilesMap);

  console.debug('[preview] Sandpack files prepared:', {
    totalFiles: Object.keys(sandpackFiles).length,
    aiFiles: files.length,
  });

  return {
    template: "react-ts",
    files: sandpackFiles,
    dependencies: FIXED_SANDPACK_DEPS,
  };
}

/**
 * Convert API response (files map) directly to Sandpack format
 */
export function adaptFileMapToSandpack(filesMap: Record<string, string>): PreviewAdapterResult {
  // Validate: Must have src/App.tsx
  if (!filesMap['src/App.tsx'] && !filesMap['/src/App.tsx']) {
    throw new Error('Generated code missing src/App.tsx');
  }

  // Build final file map with base template + AI files
  const sandpackFiles = buildSandpackFiles(filesMap);

  console.debug('[preview] Sandpack files prepared from map:', {
    totalFiles: Object.keys(sandpackFiles).length,
    aiFileKeys: Object.keys(filesMap),
  });

  return {
    template: "react-ts",
    files: sandpackFiles,
    dependencies: FIXED_SANDPACK_DEPS,
  };
}
